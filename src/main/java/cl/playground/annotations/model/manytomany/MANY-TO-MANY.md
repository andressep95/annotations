# Relación Many-to-Many con Tabla de Unión

La relación Many-to-Many se implementa usando tres clases:

- `Product`: Entidad principal de productos
- `User`: Entidad principal de usuarios
- `UserProduct`: Tabla de unión con atributos adicionales

## Clase Product

### Código Java

```java

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(
    name = "products",
    uniqueConstraints = @UniqueConstraint(
        name = "uk_product_name",
        columnNames = {"name"}
    )
)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(
        name = "name",
        length = 100,
        nullable = false
    )
    private String name;

    @Column(
        name = "price",
        precision = 10,
        scale = 2
    )
    private BigDecimal price;

    @Column(
        name = "stock",
        columnDefinition = "INTEGER DEFAULT 0"
    )
    private Integer stock;

    @Column(
        name = "created_at",
        columnDefinition = "DATE DEFAULT CURRENT_DATE"
    )
    private LocalDate createdAt;

    @OneToMany(
        mappedBy = "product",
        cascade = CascadeType.ALL,
        orphanRemoval = true
    )
    private Set<UserProduct> userProducts;
}
```

### DDL Generado

```sql
create table products (
    created_at DATE DEFAULT CURRENT_DATE,
    price numeric(10,2),
    stock INTEGER DEFAULT 0,
    id bigint generated by default as identity,
    name varchar(100) not null,
    primary key (id),
    constraint uk_product_name unique (name)
)
```

### Explicación del Mapeo

1. **Atributos básicos**:
    - `id`: Se convierte en `bigint` con autoincremento
    - `name`: Se convierte en `varchar(100)` con restricción `not null`
    - `price`: Se convierte en `numeric(10,2)` permitiendo decimales
    - `stock`: Se convierte en `INTEGER` con valor por defecto 0
    - `createdAt`: Se convierte en `DATE` con valor por defecto la fecha actual

2. **Relación Many-to-Many**:
    - `@OneToMany`: No genera columnas en el DDL
    - La relación se maneja en la tabla de unión `user_products`

## Clase User

### Código Java

```java

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(
    name = "users",
    uniqueConstraints = {
        @UniqueConstraint(
            name = "uk_user_name",
            columnNames = {"name"}
        ),
        @UniqueConstraint(
            name = "uk_user_email",
            columnNames = {"email"}
        )
    }
)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(
        name = "name",
        length = 100,
        nullable = false
    )
    private String name;

    @Column(
        name = "email",
        length = 150,
        nullable = false
    )
    private String email;

    @Column(
        name = "created_at",
        columnDefinition = "DATE DEFAULT CURRENT_DATE"
    )
    private LocalDate createdAt;

    @OneToMany(
        mappedBy = "user",
        cascade = CascadeType.ALL,
        orphanRemoval = true
    )
    private Set<UserProduct> userProducts;
}
```

### DDL Generado

```sql
create table users (
    created_at DATE DEFAULT CURRENT_DATE,
    id bigint generated by default as identity,
    name varchar(100) not null,
    email varchar(150) not null,
    primary key (id),
    constraint uk_user_name unique (name),
    constraint uk_user_email unique (email)
)
```

### Explicación del Mapeo

1. **Atributos básicos**:
    - `id`: Se convierte en `bigint` con autoincremento
    - `name`: Se convierte en `varchar(100)` con restricción `not null`
    - `email`: Se convierte en `varchar(150)` con restricción `not null`
    - `createdAt`: Se convierte en `DATE` con valor por defecto la fecha actual

2. **Relación Many-to-Many**:
    - `@OneToMany`: No genera columnas en el DDL
    - La relación se maneja en la tabla de unión `user_products`

## Clase UserProduct (Tabla de Unión)

### Código Java

```java

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "user_products")
public class UserProduct {
    @EmbeddedId
    private UserProductId id;

    @ManyToOne
    @MapsId("userId")
    @JoinColumn(
        name = "user_id",
        foreignKey = @ForeignKey(name = "fk_userproduct_user")
    )
    private User user;

    @ManyToOne
    @MapsId("productId")
    @JoinColumn(
        name = "product_id",
        foreignKey = @ForeignKey(name = "fk_userproduct_product")
    )
    private Product product;

    @Column(
        name = "quantity",
        nullable = false
    )
    private int quantity;

    @Column(
        name = "order_date",
        columnDefinition = "DATE DEFAULT CURRENT_DATE"
    )
    private LocalDate orderDate;

    @Embeddable
    static class UserProductId {
        private Long userId;
        private Long productId;
    }
}


```

### DDL Generado

```sql
create table user_products (
    order_date DATE DEFAULT CURRENT_DATE,
    quantity integer not null,
    product_id bigint not null,
    user_id bigint not null,
    primary key (product_id, user_id)
)

alter table if exists user_products 
    add constraint fk_userproduct_product 
    foreign key (product_id) 
    references products

alter table if exists user_products 
    add constraint fk_userproduct_user 
    foreign key (user_id) 
    references users
```

### Explicación del Mapeo

1. **Clave primaria compuesta**:
    - `@EmbeddedId`: Define una clave primaria compuesta usando `UserProductId`
    - Los campos `userId` y `productId` del `UserProductId` se convierten en las columnas de la clave primaria

2. **Relaciones Many-to-One**:
    - `@MapsId`: Mapea los campos del ID embebido a las columnas correspondientes
    - `@JoinColumn`: Define las columnas de unión y sus claves foráneas
    - Las claves foráneas se generan como constraints separados

3. **Atributos adicionales**:
    - `quantity`: Se convierte en `integer not null`
    - `orderDate`: Se convierte en `DATE` con valor por defecto la fecha actual

## Observaciones sobre la Relación Many-to-Many

1. **Implementación con atributos adicionales**:
    - Se usa una tabla de unión con entidad propia (`UserProduct`) porque necesitamos almacenar `quantity` y `orderDate`
    - Si no necesitáramos estos atributos adicionales, podríamos usar una relación `@ManyToMany` simple

2. **Bidireccionalidad**:
    - La relación es bidireccional, mantenida por los `Set<UserProduct>` en ambas entidades principales
    - `mappedBy` en los `@OneToMany` indica que la relación es manejada por el otro lado

3. **Claves foráneas**:
    - Se generan explícitamente con nombres personalizados usando `@ForeignKey`
    - Se implementan como constraints ALTER TABLE separados

4. **Gestión de la persistencia**:
    - `CascadeType.ALL`: Las operaciones en la entidad principal se propagan a las relaciones
    - `orphanRemoval = true`: Los registros en la tabla de unión se eliminan cuando se remueven de la colección